# 统一配置系统

Aha 提供了一个配置系统，将所有模块的配置项集中在一个文件中，方便用户调整。

```yaml
bots: ...
aha: ...
cache: ...
log: ...

modules.a:
  # key1 的注释
  key1: "选项1" # 选项1, 选项2
  # key2 的注释
  key2:
  - 1
modules.b: ...
```

## 注册配置项

```python
from core.config import Option, cfg

KEY1: str = cfg.register("key1", Option("选项1", "选项2"), "key1 的注释")
KEY2: tuple = cfg.register("key2", (1,), "key2 的注释")
```

如上，通过 `cfg.register` 方法注册配置项，第一个参数是配置项的键名，第二个参数是配置项的默认值，第三个参数是配置项的注释。

`Option` 对象会自动将第一个值作为默认值，且将所有选项通过行尾注释提示用户。

该配置系统具备类型验证能力，会自动将配置文件中的值转换为与第二个参数默认值相同的类型。如果默认值是 Sequence 或 Mapping，会递归验证。

## 一些限制

`Config` 实例是全局唯一的，子进程不可直接引用该配置系统。

值存在类型限制，必须为 `Option`、`int`、`float`、`Sequence`、`Mapping`、dataclass、[attrs](https://github.com/python-attrs/attrs)、[Pydantic](https://github.com/pydantic/pydantic) Model 或 `None`。

键也存在一些限制。因为读取配置项时**会先从 `aha` 读取**，其次是[表达式字段提取器](./事件匹配表达式.md#可注册提取器)的字段，最后才轮到模块自己的配置项。

### 目前一定冲突的键名有：

`base64_buffer`、`bot_prefs`、`bot_selector_strategy`、`cache_conv`、`database`、`debug`、`default_group_list`、`default_group_list_mode`、`default_user_list`、`default_user_list_mode`、`execution_mode`、`global_msg_prefix`、`lang`、`limit`、`memory_level`、`playwright`、`point_feat`、`private`、`super`

### 可能冲突的键名有（即可注册提取器的表达式字段名）：

`validated`

### 具有特殊用途的键名有：

`group_list`、`group_list_mode`、`msg_prefix`、`user_list`、`user_list_mode`

## 其它方法

### `cfg.set(key, value)`

设置配置项的值，返回设置的值。

### `cfg.get(key, default=None)`

获取配置项的值，如果不存在则返回 `default`。

### `cfg.get_msg_prefix()`

获取 `msg_prefix` 配置项的值，如果不存在则返回 `aha` 配置项的 `global_msg_prefix` 配置项的值。

若只有单个特殊字符则返回半角。

### `cfg.get_group_blacklist()`

获取模块级群组黑名单与全局黑名单的并集。

### `cfg.get_user_blacklist()`

获取模块级用户黑名单与全局黑名单的并集。

### `cfg.get_group_whitelist()`

获取模块级群组白名单，不存在则返回全局白名单。

### `cfg.get_user_whitelist()`

获取模块级用户白名单，不存在则返回全局白名单。