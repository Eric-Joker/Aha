# 事件匹配表达式

Aha 采用特有的嵌入式 DSL（领域特定语言）实现回调的事件匹配的筛选。通过组合**字段**和**运算符**，可以构建从简单到极其复杂的事件匹配条件，使回调能够通过简洁、直观的语法精准地响应各类事件。

> 由于存在回调间数据隔离的逻辑，建议尽可能使用表达式的非`黑魔法`特性进行前置事件筛选以提升性能，而非回调内部后验。
>
> 黑魔法特性包括 `ApplyTo` 运算符、[属性穿透](#属性穿透)、[pre_hook](./订阅与发布事件.md#预处理匹配的消息内容) 。

## 示例

```python
from core.dispatcher import on_message
from core.expr import Pprefix, Pmsg_chain

@on_message(r"say\s?(.+)", Pprefix == True, Pplatform != "QQ")
```

这个条件匹配：
- 忽略前缀后内容以 `say` 开头（fullmatch），后面跟着任意内容；
- 消息内容必须带有前缀；
- 消息来源平台不为 QQ；

传递给回调函数的多个表达式为并列关系。

[**更多示例**](./示例.md)

## 字段

字段代表从事件中提取到的特定属性，例如消息文本、事件类型等。

Aha 原生的字段都在 `core.expr.PM` 类中定义，可通过[别名](#别名)（如 `Pmsg`）访问。

> 每个字段的实例应全局唯一。

### 提取值

每个字段都指定了从[事件对象](../数据结构/事件对象.md)提取为特定属性的逻辑，其返回值类型决定了可进行的运算。

对于多元表达式，字段存在优先级的概念，会同时影响与其直接相关的二元表达式的优先级。越大越优先评估，越小越靠后评估，若为 0 会尽可能保持原顺序。

Aha 原生字段：

| 字段 | 类型 | 说明 | 优先级 |
| --- | --- | --- | --- |
| `PM.message` | str | 去除前缀后的字符串格式的消息内容。 | 0 |
| `PM.message_chain` | [MessageChain](../数据结构/消息序列与消息段.md#messagechain) | 去除前缀后的消息链。 | 0 |
| `PM.command` | list[str \| [MsgSeg](../数据结构/消息序列与消息段.md#msgseg)] | 按空格分割的命令参数列表。 | 0 |
| `PM.type_` / `PM.request` / `PM.notice` / `PM.meta` | [EventType](../数据结构/事件对象.md#eventtype) | 事件类型枚举。 | 39 |
| `PM.sub_type` | [EventSubType](../数据结构/事件对象.md#eventsubtype) | 事件子类型。 | 40 |
| `PM.isgroup` | bool | 是否为群聊消息。 | 6 |
| `PM.isprivate` | bool | 是否为私聊消息。 | 7 |
| `PM.gid` | int | 群组的 Aha ID。 | 3 |
| `PM.uid` | int | 用户的 Aha ID。 | 2 |
| `PM.group` | [Group](../数据结构/平台个体.md#modelscoregroup) | 平台群组个体。 | 5 |
| `PM.user` | [User](../数据结构/平台个体.md#modelscoreuser) | 平台用户个体。 | 4 |
| `PM.platform` | str | 事件来源平台名。 | 8 |
| `PM.bot` | int | 接收到该事件的适配器实例 ID。 | 10 |
| `PM.prefix` | bool | 消息是否包含[前缀](./内置轮子与最佳实践/消息前缀.md) 。| 0 |
| `PM.admin` | bool | 触发者是否为群管理员。 | -50 |
| `PM.super` | bool | 触发者是否为超级用户。 | 50 |
| `PM.validated` | bool | 触发者是否通过验证（需模块[注册提取器](#注册-pmvalidated-提取器)）。 | -10 |
| `PM.limit` | bool | 触发者的限速状态，为 True 代表状态正常未限制。 | -999 |

### 个别字段的特殊逻辑

- **`PM.message`**：
  - 为其进行正则表达式相关运算时会将 Match 对象作为 `match_` 关键字参数**传递给回调函数**。
  - 除此之外还有[本地化特性](./本地化.md)的相关逻辑。

- **`PM.limit`**：其提取器是计数、验证一体的。当 `PM.limit == False` 时会直接跳过提取器逻辑并将提取值设为 True。

- **`PM.command`**：
  - 提取时，先从消息中移除前缀，然后遍历消息链：
        
    若为[Text 消息段](../数据结构/消息序列与消息段.md#text)则将内容按空格分割为多个字符串参数。若含换行，换行后的内容与最后一个参数合并（保留换行）。

    非 Text 消息段作为独立参数保留。
  - 基本用法：进行 `==`、`PrefixOf` 和 `SingletonOf` 相关的运算时，第二操作数可指定为期望的参数列表，列表元素可以是：
    - str：要求对应位置的参数严格相等。
    - 类型注解：比如 `Image`。要求对应位置的参数验证通过，且会将这些参数组成列表通过 `args` 关键字参数**传递给回调函数**。

    `PrefixOf` 匹配后剩余位置的参数也会依次存入 `args` 列表。
  - 示例，假设去除前缀后的消息内容为 `"echo hello world"`：
    ```python
    PM.command == ["echo", str, Text]  # args = ["hello", "world"]
    PM.command == ["echo", "hello", "world"]  # args = []
    PM.command.prefixof(["echo"])  # args = ("hello", "world")
    ```

## 运算符

运算符需依托于表达式对象调用，例如字段就是表达式对象：`Pmsg == "value"`。

若评估出错会中止整个表达式的后续评估并缄默。若有需要可见[调试](#调试)。
| 运算符 | 类 | 说明 | 示例 |
| --- | --- | --- | --- |
| `&` / `and_()` | `And` | 逻辑与，所有子条件必须为真。 | `(Pmsg == "ping") & (Padmin == True)` / `And(Pmsg == "ping", Padmin == True)` |
| `\|` / `or_()` | `Or` | 逻辑或，至少一个子条件为真。 | `(Pplatform == "QQ") \| (Pplatform == "WeChat")` / `Or(Pplatform == "QQ", Pplatform == "WeChat")` |
| `~` / `not_()` | `Not` | 逻辑非，对子条件取反。 | `~(Puid == 123456)` / `Not(Puid == 123456)` |
| `==` | `Equal` | 相等比较。 | `Pmsg == "hello"` |
| `!=` | `NotEqual` | 不等比较。 | `Pmsg != "hello"` |
| `.in_()` | `In` | 左侧值是否包含在容器中。 | `Puid.in_({1,2,3})` |
| `.notin()` | `NotIn` | 左侧值是否不包含在容器中。 | `Puid.notin({4,5,6})` |
| `.contains()` | `Contains` | 左侧容器是否包含指定元素。 | `Pmsg_chain.contains("123")` |
| `.notcontains()` | `NotContains` | 左侧容器是否不包含指定元素。 | `Pmsg_chain.notcontains("123")` |
| `.prefixof()` | `PrefixOf` | 左侧序列是否是指定序列的前缀。 | `Pcommand.prefixof(["help", "status"])` |
| `.notprefixof()` | `NotPrefixOf` | 左侧序列是否不是指定序列的前缀。 | `Pcommand.notprefixof(["admin"])` |
| `.suffixof()` | `SuffixOf` | 左侧序列是否是指定序列的后缀。 | `Pmsg.suffixof(".txt")` |
| `.notsuffixof()` | `NotSuffixOf` | 左侧序列是否不是指定序列的后缀。 | `Pmsg.notsuffixof(".jpg")` |
| `.match()` | `Match` | 字符串是否从开头匹配正则表达式。 | `Pmsg.match(r"hello\s+world")` |
| `.fullmatch()` | `FullMatch` | 字符串是否完全匹配正则表达式。 | `Pmsg.fullmatch(r"\d+")` |
| `.search()` | `Search` | 字符串是否包含正则表达式的匹配。 | `Pmsg.search(r"http://")` |
| `.validateby()` | `ValidateBy` | 左侧对象是否符合指定类型注解。 | `Pmsg_chain.validateby(list[At])` |
| `.applyto()` | `ApplyTo` | 对左侧对象应用 Callable，返回结果。 | `Pmsg.applyto(str.upper)` |
| `.filter()` | `ApplyTo`(配合 `partial(filter, 参数)`) | 对 Sequence 应用 `filter`，返回迭代器。 | `Pmsg_chain.filter(lambda seg: isinstance(seg, Text))` |
| `.to_msg_seq()` | `ApplyTo`(配合 `MessageChain`) | 将左侧对象转换为 [`MessageChain`](../数据结构/消息序列与消息段.md#messagechain)。 | `Pmsg.to_msg_seq()` |
| `.singletonof()` | `SingletonOf` | 序列是否只有一个元素且等于指定对象。 | `Pcommand.singletonof(0)` |
| `.notsingletonof()` | `NotSingletonOf` | 序列不满足 `singletonof`。 | `Pcommand.notsingletonof(0)` |

> 运算符的优先级遵循 Python 运算符优先级规则。

> 这里有两个生成正则表达式片段的工具：[`at_or_str`](./内置轮子与最佳实践/零碎%20utils.md#at_or_str) 和[消息段类可作为正则](../数据结构/消息序列与消息段.md#msgseg)。

> 大部分运算符实质上只是用所有参数生成一个表达式类的实例并返回，所以也可以直接构建实例：
> ```python
> from core.expr import And, Equal, In
> @on_message(And(Equal(Pmsg, "ping"), In(Puid, {1,2,3})))

> <small style="color: gray;">由于存在评估优先级的特性存在，我想不到好的方案以实现变量功能。</small>

### 属性穿透
表达式实例重载了 `__getattr__` 和 `__call__`。因此，评估时表达式会将上述未声明的公共属性/方法、部分魔术方法调用穿透到提取值上。

例如 `Pmsg_chain[0]` 会生成表达式对象并在评估时提取为第一个消息段。

会穿透的魔术方法有：`__lt__`、`__le__`、`__gt__`、`__ge__`、`__getitem__`、`__add__`、`__sub__`、`__mul__`、`__matmul__`、`__truediv__`、`__floordiv__`、`__mod__`、`__pow__`、`__divmod__`、`__radd__`、`__rsub__`、`__iadd__`、`__isub__`。

示例：
```python
@on_message(Pmsg.search(r"test(.+)test")[1].split()[0].lower() == "test")
```

其中对 `search` 和 `split` 的返回值的 `__getitem__` 调用是穿透到提取值上的；`split` 和 `lower` 是先穿透属性名获取到方法后进行调用的。

> 不会额外拦截私有属性与方法，但请注意与表达式对象自有属性冲突的风险。

## 默认表达式

通过装饰器注册回调时，系统会自动为某些字段补充默认表达式，并与通过[回调函数装饰器](./订阅与发布事件.md)的参数直接声明的表达式进行逻辑与合并。当然，若显式声明了这些字段则不会添加对应的默认表达式。

以下是 Aha 原生的默认表达式：

- **群组黑白名单**：若在[配置文件中配置了](../安装与使用.md#面向平台用户群组的黑白名单)群组白名单，则有 `PM.group.in_(cfg.get_group_whitelist())`；若配置了黑名单，则有 `PM.group.notin(cfg.get_group_blacklist())`。
- **用户黑白名单**：类似地，`PM.user` 会根据模块配置添加默认黑白名单。
- **私聊允许**：若配置项 `aha.private`为 `false` 则有 `PM.isprivate == False`。
- **已验证用户**：当存在为 `PM.validated` 字段[注册提取器](#注册-pmvalidated-提取器)的模块时，则有 `PM.validated == True`。
- **面向单用户的全局限速**：若配置项 `aha.limit` 不为 `0` 则有 `PM.limit == True`。注意，该默认表达式对 [`Notice` 和 `Request` 事件](./订阅与发布事件.md)也有效。

> 对于通过 `on_meta` 注册的回调，默认情况下系统**不会**添加上述默认表达式。

## 人性化设计

为了让表达式更简洁易写，系统提供了多种便捷特性。

### 简写为非表达式对象

可以尝试在[注册回调装饰器](./订阅与发布事件.md)传入非表达式的 Python 对象作为参数，系统会尝试依据类型自动将其转换为表达式：

- **str**  
  - 若传递给 `on_message` 则转化为 `PM.message.fullmatch(re.compile(str, re.I))`
  - 否则，若作为顶层参数依次出现，则
    - 第一个字符串 → `PM.type_ == str1`
    - 第二个（若有）→ `PM.sub_type == str2`。
- **re.Pattern** → `PM.message.fullmatch(re.Pattern)`
- **list** → `PM.command == list`
- **tuple** → `PM.command == tuple`
- **类型注解**（如 `str`、`List[str]`）→ `PM.message_chain.validateby(类型注解)`
- **`None`** 会被忽略

例：
```python
@on_message("ping")  # 等价于 PM.message.fullmatch("ping")
@on_message(["help", str])  # 等价于 PM.command == ["help", str]
@on_notice("group_increase", "approve")  # 等价于 (PM.type_ == "group_increase") & (PM.sub_type == "approve")
```

### 运算符自动调整

某些字段与特定运算符组合时，系统会调整运算符以符合语义：

- **对 `PM.message_chain` 使用 `==`**：若右侧是类型注解，则自动转换为 `validateby` 运算符，而不是简单的相等比较。
- **对 `PM.command` 使用 `==` / `!=`**：若右侧是字符串，则自动转换为 `SingletonOf` / `NotSingletonOf` 运算符。

### 操作数自动转换

当运算符的非表达式操作数类型不匹配时，系统会进行转换：

- **正则运算符**（`match`、`fullmatch`、`search`）：如果指定对象是 str，会自动编译为**忽略大小写**的正则表达式。

### 对[消息链](../数据结构/消息序列与消息段.md#messagechain)的类型注解支持

通过[回调函数装饰器](./订阅与发布事件.md)的参数直接声明的表达式中未使用 `PM.message`、`PM.message_chain`、`PM.command` 字段，且被装饰函数的 `event` 参数存在指定了 [`Message`](../数据结构/事件对象.md#message) 泛型的类型注解，则会基于此泛型注解生成 `Pmsg_chain.validateby(MessageChain[泛型注解])` 表达式并与直接声明的表达式进行逻辑与合并。

如：
```python
@on_message()  # 会自动生成 Pmsg_chain.validateby(MessageChain[Image])
async def _(event: Message[Image]): ...
```

### 别名

| 字段 | 别名 |
| --- | --- |
| `PM.message` | `Pmsg`、`PM.msg`、`Pmessage` |
| `PM.message_chain` | `Pmsg_chain`、`PM.msg_chain` |
| `PM.command` | `Pcommand` |
| `PM.isgroup` | `Pisgroup` |
| `PM.isprivate` | `Pisprivate` |
| `PM.gid` | `Pgid` |
| `PM.uid` | `Puid` |
| `PM.group` | `Pgroup` |
| `PM.user` | `Puser` |
| `PM.platform` | `Pplatform` |
| `PM.bot` | `Pbot` |
| `PM.prefix` | `Pprefix` |
| `PM.admin` | `Padmin` |
| `PM.super` | `Psuper` |
| `PM.validated` | `Pvalidated` |
| `PM.limit` | `Plimit` |

这些别名可以直接从 `core.expr` 导入使用。

## 调试

若[配置文件](./统一配置系统.md)中 `aha.debug` 为 `true` 则会进入调试模式：
 - 在[注册回调装饰器](./订阅与发布事件.md)将关键字参数 `debug` 传为 `True`，则会在表达式评估时会打印每个二元运算符操作数与匹配结果。
    ```python
    @on_message("ping", debug=True)
    ```

 - 会打印表达式评估时出现的未捕获异常。

## 进阶教程

### 各个元素的 Python 本质

- **主要流程**：向[注册回调装饰器](./订阅与发布事件.md)传入表达式后，会构造出由表达式对象组成的树，在每次接收到新的事件时通过 `core.expr.evaluate` 函数进行递归评估。
- **表达式对象**：继承自 `Expr` 的类的实例。**字段**与**二元/逻辑表达式实例**都是表达式对象。
- **字段**：`core.expr.FieldClause` 的实例。其 `field` 参数是 [`Field 描述符`](#field-描述符)，定义了提取器、默认表达式、优先级等字段元信息。
- **二元表达式**：继承自 `BinaryExpr` 的类，如 `Equal`、`In` 等，实现了 `_evaluate_logic` 方法进行实际求值。
- **逻辑表达式**：`And`、`Or`、`Not`，具有 `clause` 属性以存储子表达式。

### 注册 `PM.validated` 的提取器

`PM.validated` 的提取器不是静态定义的，允许模块通过 `register_extractor` 装饰器注册。

```python
from core.expr import PM, register_extractor

@register_extractor(PM.validated)
async def my_validator(event: BaseEvent):
    return True
```

若存在多个模块注册同一字段的提取器，可由[配置文件](./统一配置系统.md)中的 `expr_extractors.validated` 配置项选择其中一个模块的。可通过 `cfg.validated` 获取当前模块的提取器是否被选取。

### 新增字段

通过新增字段实现将自定义筛选逻辑提升至前验，不仅可以提升性能还可以与其他字段的特性打配合。

声明一个 `core.expr.FieldClause` 实例即可。

**自定义的字段的任意逻辑均不应该对事件对象中的任何内容进行任何写入行为！**

```python
from core.expr import Field, FieldClause

first_seg = FieldClause("first_seg", Field(lambda event: event.message[0]))

@on_message(first_seg.validateby(Text))
async def _(): ...
```

| 参数 | 类型 | 描述 |
| --- | --- | --- |
| `name` | `str` | 名字，应全模块唯一。 |
| `field` | [`Field`](#field-描述符) | 字段元信息。 |

#### Field 描述符

| 参数 | 类型 | 描述 |
| --- | --- | --- |
| extractor | Callable[[[BaseEvent](../数据结构/事件对象.md#baseevent)], Any] | 从[事件对象](../数据结构/事件对象.md)中提取值的方法。 |
| default | Callable[[FieldClause], Expr \| Any] | 默认表达式。若与最高级二元表达式为并列关系的表达式中没有引用过该字段，会自动添加默认表达式。**自该字段诞生起，默认表达式会作用于所有模块之后注册的所有回调。** |
| priority | int | 优先级。 |
| binary_semantics | Callable[[type["BinaryExpr"], Any], type["BinaryExpr"]] | [运算符自动调整](#运算符自动调整)的实现，转化二元表达式的类型。第二个参数是另一操作数。 |
| rhs_converter | Callable[[Any, type["BinaryExpr"], [EventCategory](../数据结构/事件对象.md#modelscoreeventcategory)], Any] | [操作数自动转换](#操作数自动转换)的实现，修正二元表达式另一端的值。若声明了 `binary_semantics`，第二个参数传递的是转换后的二元表达式类型。 |
| operand_types | dict[type \| Iterable[type], BinaryExpr] | [简写为非表达式对象](#简写为非表达式对象)的实现，注册类型对应的字段与二元运算符。 |
| overrides | dict | 二元表达式评估时，若另一操作数为 key ，设评估结果为 value，此时不再调用提取器。 |
| cache | [CacheConfig](#cacheconfig) | 配置并启用二元表达式评估结果缓存。 |
| skip_default_on_meta | bool | 由 `on_meta` 函数注册时，不添加该字段的默认表达式。默认值为 True。 |

#### CacheConfig

| 参数 | 类型 | 描述 |
| --- | --- | --- |
| cache | [Cache](./内置轮子与最佳实践/缓存器.md) | 缓存器。 |
| key_func | Callable[[type[BinaryExpr], Any, [BaseEvent](../数据结构/事件对象.md#baseevent)], Hashable] | 生成缓存键的函数。第二个参数为另一操作数。 |
| ignore_cache | Callable[[Any, FieldClause, Any, [BaseEvent](../数据结构/事件对象.md#baseevent)], bool] | 决定是否缓存结果的函数。参数依次为：位置参数 评估结果、`left` 当前操作数、`right` 另一操作数、`msg` [事件](../数据结构/事件对象.md)。返回为 `True` 时不进行本次缓存。 |
| skip_cache | Callable[[type[BinaryExpr]], bool] | 决定是否执行缓存相关逻辑。返回为 `True` 时不执行。 |
| contextvars | Iterable[str] | 同时缓存评估结束后指定的 ContextVar，缓存命中时应用。 |

### 新增运算符

继承 `BinaryExpr` 以定义一个新的二元表达式类并实现 `_evaluate_logic` 方法。具体怎么实现自己研究，我相信你。

> 主要是当前的设计并不算 API 友好，不适合暴露。
